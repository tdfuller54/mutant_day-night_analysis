import pandas as pd
import numpy as np
import scipy.stats as stats
import matplotlib.pyplot as plt
import datetime as dt
import seaborn as sns

from operator import itemgetter

# pd.set_option('display.height', 500)
pd.set_option('display.max_rows', 500)
pd.set_option('display.max_columns', 500)
pd.set_option('display.width', 300)
np.set_printoptions(threshold=np.nan)

data = pd.read_table("M:\\Lab\\Tyson\\Syne1b master folder\\mutant day-night data\\P22219 s1b-g d196 day-night assay"
                     "\\P22219 s1bg d196 day-night.XLS")



## convert sttime to datetime in python and use the timestamp.round function to round this to the nearest
##minute so we can use the hour value for day-night subsetting later
data["sttime"] = pd.to_datetime(data["sttime"])
data["sttime"] = data["sttime"].apply(lambda x: pd.Timestamp.round(x, 'min'))
data["sttime"] = data["sttime"].apply(lambda x: x.time())
#data[["sttime"]].info()
#print(data["sttime"])

## Since the column is now a time object the hour and minute columns can be generated by calling
## datetime functions. This returns values as int64 type
data['hour'] = data['sttime'].apply(lambda x : x.hour)
data['minute'] = data['sttime'].apply(lambda x : x.minute)
##print(data[['stdate', 'sttime', 'hour', 'minute']])
##data[['hour','minute']].info()

## This method allows python to generate a list based on lines of a txt file to not manually type them all in
with open("M:\\Lab\\Tyson\\Syne1b master folder\\mutant day-night data\\"
          "P22219 s1b-g d196 day-night assay\\wt_wells.txt", "r") as WW:
    lines = WW.readlines()
    WT_wells = [l.strip() for l in lines if l.strip()]

with open("M:\\Lab\\Tyson\\Syne1b master folder\\mutant day-night data\\"
          "P22219 s1b-g d196 day-night assay\\het_wells.txt", "r") as HW:
    lines = HW.readlines()
    Het_wells = [l.strip() for l in lines if l.strip()]

with open("M:\\Lab\\Tyson\\Syne1b master folder\\mutant day-night data\\"
           "P22219 s1b-g d196 day-night assay\\mutant_wells.txt", "r") as MW:
   lines = MW.readlines()
   Mut_wells = [l.strip() for l in lines if l.strip()]


#print (WT_wells)
#print(Mut_wells)
#print(Het_wells)

## This is modifying Anthony's example code some to work off the animal column or actual well number to group
## larvae by genotype
data['group'] = data['animal'].apply(lambda x: "WT" if x in WT_wells else "mut" if x in Mut_wells else
                                     "het" if x in Het_wells else "NA")

##Using example from Anthony will now remove all unnecessary columns using appropriate column names
data = data[['animal', 'group', 'start', 'end', 'actinteg', 'stdate', 'sttime', 'hour', 'minute']]
#print(data)




##Use Anthony's example to group by day, treatment group, hour, then minute and apply mean over the groupings
## This will get average activity values for each minute but still will want to separate by each night and day later on
grouped = data.groupby(['stdate','group', 'hour', 'minute'], as_index=False).mean()

## From Anthony quickly visualize the data to see if any trends
sns.set_context("talk")
# plt.figure(figsize=(8,6))
g = sns.FacetGrid(data=grouped, col="stdate", hue="group", height=6)
g.map(sns.lineplot(), "hour", "actinteg")
sns.despine()
plt.legend()
plt.show()

##get area under curve for each fish
WT_night4_area = WT_night4.groupby('animal', as_index=True)['actinteg'].agg(np.trapz)
WT_day5_area = WT_day5.groupby('animal', as_index=True)['actinteg'].agg(np.trapz)
WT_night5_area = WT_night5.groupby('animal', as_index=True)['actinteg'].agg(np.trapz)
WT_day6_area = WT_day6.groupby('animal', as_index=True)['actinteg'].agg(np.trapz)
WT_night6_area = WT_night6.groupby('animal', as_index=True)['actinteg'].agg(np.trapz)
lg_night4_area = lg_night4.groupby('animal', as_index=True)['actinteg'].agg(np.trapz)
lg_day5_area = lg_day5.groupby('animal', as_index=True)['actinteg'].agg(np.trapz)
lg_night5_area = lg_night5.groupby('animal', as_index=True)['actinteg'].agg(np.trapz)
lg_day6_area = lg_day6.groupby('animal', as_index=True)['actinteg'].agg(np.trapz)
lg_night6_area = lg_night6.groupby('animal', as_index=True)['actinteg'].agg(np.trapz)
sh_night4_area = sh_night4.groupby('animal', as_index=True)['actinteg'].agg(np.trapz)
sh_day5_area = sh_day5.groupby('animal', as_index=True)['actinteg'].agg(np.trapz)
sh_night5_area = sh_night5.groupby('animal', as_index=True)['actinteg'].agg(np.trapz)
sh_day6_area = sh_day6.groupby('animal', as_index=True)['actinteg'].agg(np.trapz)
sh_night6_area = sh_night6.groupby('animal', as_index=True)['actinteg'].agg(np.trapz)

print(WT_night4_area)
all_night4 = []
all_night4.extend(WT_night4_area_821)
all_night4.extend(WT_night4_area)
print(all_night4)

##do t test and mann whitney test comparing days and nights of area under curve each group
print("stats for WTvlg night 4")
print(stats.mannwhitneyu(WT_night4_area, lg_night4_area))
print("stats for WTvlg day 5")
print(stats.mannwhitneyu(WT_day5_area, lg_day5_area))
print("stats for WTvlg night 5")
print(stats.mannwhitneyu(WT_night5_area, lg_night5_area))
print("stats for WTvlg day6")
print(stats.mannwhitneyu(WT_day6_area, lg_day6_area))
print("stats for WTvlg night 6")
print(stats.mannwhitneyu(WT_night6_area, lg_night6_area))

print("stats for WTvsh night 4")
print(stats.mannwhitneyu(WT_night4_area, sh_night4_area))
print("stats for WTvsh day 5")
print(stats.mannwhitneyu(WT_day5_area, sh_day5_area))
print("stats for WTvsh night 5")
print(stats.mannwhitneyu(WT_night5_area, sh_night5_area))
print("stats for WTvsh day6")
print(stats.mannwhitneyu(WT_day6_area, sh_day6_area))
print("stats for WTvsh night 6")
print(stats.mannwhitneyu(WT_night6_area, sh_night6_area))

# data taking total movement for each fish during each period


## generate box and whisker plots to show the values for area under the curve, total movement, and ave movement per min


plt.figure(1)
night4_area = [WT_night4_area, lg_night4_area, sh_night4_area]
plt.boxplot(night4_area, whis=[5, 95], labels=["WT", "lg", "sh"], positions=[1, 2, 3], widths=0.5)
plt.xlim(0.25, 3.75)
plt.title("Area Under the Curve Night 4")

plt.figure(2)
day5_area = [WT_day5_area, lg_day5_area, sh_day5_area]
plt.boxplot(day5_area, whis=[5, 95], labels=["WT", "lg", "sh"], positions=[1, 2, 3], widths=0.5)
plt.xlim(0.25, 3.75)
plt.title("Area Under the Curve Day 5")

plt.figure(3)
night5_area = [WT_night5_area, lg_night5_area, sh_night5_area]
plt.boxplot(night5_area, whis=[5, 95], labels=["WT", "lg", "sh"], positions=[1, 2, 3], widths=0.5)
plt.xlim(0.25, 3.75)
plt.title("Area Under the Curve Night 5")

plt.figure(4)
day6_area = [WT_day6_area, lg_day6_area, sh_day6_area]
plt.boxplot(day6_area, whis=[5, 95], labels=["WT", "lg", "sh"], positions=[1, 2, 3], widths=0.5)
plt.xlim(0.25, 3.75)
plt.title("Area Under the Curve Day 6")

plt.figure(5)
night6_area = [WT_night6_area, lg_night6_area, sh_night6_area]
plt.boxplot(night6_area, whis=[5, 95], labels=["WT", "lg", "sh"], positions=[1, 2, 3], widths=0.5)
plt.xlim(0.25, 3.75)
plt.title("Area Under the Curve Night 6")

# plt.show()

# print(WT_day5_act_min)
# print(WT_day5_act)

## calculate the average movement by minute and standard errors for each group starting at midnight
data_WT_midnight = data_WT.loc[data_WT["end"] >= 31560]
data_lg_midnight = data_lg.loc[data_lg["end"] >= 31560]
data_sh_midnight = data_sh.loc[data_sh["end"] >= 31560]
WT_act_by_min = data_WT_midnight.groupby('end', as_index=True)['actinteg'].agg([np.mean, stats.sem])
lg_act_by_min = data_lg_midnight.groupby('end', as_index=True)['actinteg'].agg([np.mean, stats.sem])
sh_act_by_min = data_sh_midnight.groupby('end', as_index=True)['actinteg'].agg([np.mean, stats.sem])
# print(WT_act_by_min)

## generate arrays containing x and y values to plot and arrays with standard errors
x = np.array(range(526, len(WT_act_by_min) + 526))
# print (x)

y = np.around(WT_act_by_min['mean'].values, decimals=2)
y2 = np.around(lg_act_by_min['mean'].values, decimals=2)
y3 = np.around(sh_act_by_min['mean'].values, decimals=2)

# print(y)

error = np.around(WT_act_by_min['sem'].values, decimals=2)
error2 = np.around(lg_act_by_min['sem'].values, decimals=2)
error3 = np.around(sh_act_by_min['sem'].values, decimals=2)

plt.figure(6)
plt.plot(x, y, 'k-', linewidth=0.25, color="b")
plt.fill_between(x, y - error, y + error, facecolor='#add8e6')

# plt.plot(x, y2, 'k-', linewidth=0.25, color="r")
# plt.fill_between(x, y2-error2, y2+error2, facecolor='#f8cdcf')

plt.plot(x, y3, 'k-', linewidth=0.25, color="g")
plt.fill_between(x, y3 - error3, y3 + error3, facecolor='#b1e0c4')

plt.ylim(-10, 750)

plt.show()
